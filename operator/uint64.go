package operator

// Code generated by (tawesoft.co.uk/go/operator) template-numbers.py: DO NOT EDIT.


type uint64Binary struct {
    Add             func(uint64, uint64) uint64
    Sub             func(uint64, uint64) uint64
    Mul             func(uint64, uint64) uint64
    Div             func(uint64, uint64) uint64
    Mod             func(uint64, uint64) uint64
    
    And             func(uint64, uint64) uint64
    Or              func(uint64, uint64) uint64
    Xor             func(uint64, uint64) uint64
    AndNot          func(uint64, uint64) uint64
    
    Shl             func(uint64, uint) uint64
    Shr             func(uint64, uint) uint64
}

type uint64BinaryChecked struct {
    Add             func(uint64, uint64) (uint64, error)
    Sub             func(uint64, uint64) (uint64, error)
    Mul             func(uint64, uint64) (uint64, error)
    
    Shl             func(uint64, uint) (uint64, error)
    Shr             func(uint64, uint) (uint64, error)
}

var Uint64 = struct {
    Binary          uint64Binary
}{
    Binary:          uint64Binary{
        Add:        func(a uint64, b uint64) uint64 { return a + b },
        Sub:        func(a uint64, b uint64) uint64 { return a - b },
        Mul:        func(a uint64, b uint64) uint64 { return a * b },
        Div:        func(a uint64, b uint64) uint64 { return a / b },
        
        And:        func(a uint64, b uint64) uint64 { return a & b },
        Or:         func(a uint64, b uint64) uint64 { return a | b },
        Xor:        func(a uint64, b uint64) uint64 { return a ^ b },
        AndNot:     func(a uint64, b uint64) uint64 { return a &^ b },
        Mod:        func(a uint64, b uint64) uint64 { return a % b },
        
        Shl:        func(a uint64, b uint) uint64 { return a << b },
        Shr:        func(a uint64, b uint) uint64 { return a >> b },
    },
}

var Uint64Checked = struct {
    Binary          uint64BinaryChecked
}{
    Binary:         uint64BinaryChecked{
        Add:        uint64BinaryCheckedAdd,
        Sub:        uint64BinaryCheckedSub,
        Mul:        uint64BinaryCheckedMul,
        Shl:        uint64BinaryCheckedShl,
    },
}

func uint64BinaryCheckedAdd(a uint64, b uint64) (v uint64, err error) {
    if (b > 0) && (a > (maxUint64 - b)) { return v, ErrorOverflow }
    if (b < 0) && (a < (minUint64 - b)) { return v, ErrorOverflow }
    return a + b, nil
}

func uint64BinaryCheckedSub(a uint64, b uint64) (v uint64, err error) {
    if (b < 0) && (a > (maxUint64 + b)) { return v, ErrorOverflow }
    if (b > 0) && (a < (minUint64 + b)) { return v, ErrorOverflow }
    return a - b, nil
}

func uint64BinaryCheckedMul(a uint64, b uint64) (v uint64, err error) {
    if (a > (maxUint64 / b)) { return v, ErrorOverflow }
    if (a < (minUint64 / b)) { return v, ErrorOverflow }
    
    return a * b, nil
}

func uint64BinaryCheckedShl(a uint64, b uint) (v uint64, err error) {
    if b > uint(uint64MostSignificantBit(maxUint64)) { return v, ErrorOverflow }
    return v, err
}

func uint64MostSignificantBit(a uint64) (result int) {
  for a > 0 {
      a >>= 1
      result++
  }
  return result;
}
