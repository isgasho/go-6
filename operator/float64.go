package operator

// Code generated by (tawesoft.co.uk/go/operator) template-numbers.py: DO NOT EDIT.

import "math"

// Some overflow checks with reference to stackoverflow.com/a/1514309/5654201

type float64Unary struct {
    Identity        func(float64) float64
    Abs             func(float64) float64
    Negation        func(float64) float64
    Zero            func(float64) bool
    NonZero         func(float64) bool
    Positive        func(float64) bool
    Negative        func(float64) bool
}

type float64UnaryChecked struct {
    Abs             func(float64) (float64, error)
    Negation        func(float64) (float64, error)
}

type float64Binary struct {
    Add             func(float64, float64) float64
    Sub             func(float64, float64) float64
    Mul             func(float64, float64) float64
    Div             func(float64, float64) float64
    Mod             func(float64, float64) float64
    
    Eq              func(float64, float64) bool
    Neq             func(float64, float64) bool
    Lt              func(float64, float64) bool
    Lte             func(float64, float64) bool
    Gt              func(float64, float64) bool
    Gte             func(float64, float64) bool
    
    
}

type float64BinaryChecked struct {
    Add             func(float64, float64) (float64, error)
    Sub             func(float64, float64) (float64, error)
    Mul             func(float64, float64) (float64, error)
    Div             func(float64, float64) (float64, error)
    
}

type float64Nary struct {
    Add             func(... float64) float64
    Sub             func(... float64) float64
    Mul             func(... float64) float64
}

type float64NaryChecked struct {
    Add             func(... float64) (float64, error)
    Sub             func(... float64) (float64, error)
    Mul             func(... float64) (float64, error)
}

// Float64 implements operations on one (unary), two (binary), or many (nary) arguments of type float64.
var Float64 = struct {
    Unary           float64Unary
    Binary          float64Binary
    Nary            float64Nary
    Reduce          func(operatorIdentity float64, operator func(float64, float64) float64, elements ... float64) float64
}{
    Unary:          float64Unary{
        Identity:   func(a float64) float64 { return a },
        Abs:        float64UnaryAbs,
        Negation:   func(a float64) float64 { return -a },
        Zero:       func(a float64) bool { return a == 0 },
        NonZero:    func(a float64) bool { return a != 0 },
        Positive:   float64UnaryPositive,
        Negative:   float64UnaryNegative,
    },
    
    Binary:          float64Binary{
        Add:        func(a float64, b float64) float64 { return a + b },
        Sub:        func(a float64, b float64) float64 { return a - b },
        Mul:        func(a float64, b float64) float64 { return a * b },
        Div:        func(a float64, b float64) float64 { return a / b },
        
        Eq:         func(a float64, b float64) bool { return a == b },
        Neq:        func(a float64, b float64) bool { return a != b },
        Lt:         func(a float64, b float64) bool { return a <  b },
        Lte:        func(a float64, b float64) bool { return a <= b },
        Gt:         func(a float64, b float64) bool { return a >  b },
        Gte:        func(a float64, b float64) bool { return a >= b },
        
        
    },
    
    Nary:           float64Nary{
        Add:        float64NaryAdd,
        Mul:        float64NaryMul,
    },
    
    Reduce:         float64Reduce,
}

// Float64Checked implements operations on one (unary), two (binary), or many (nary) arguments of type float64, returning an
// error in cases such as overflow or an undefined operation.
var Float64Checked = struct {
    Unary           float64UnaryChecked
    Binary          float64BinaryChecked
    Nary            float64NaryChecked
    Reduce          func(operatorIdentity float64, operator func(float64, float64) (float64, error), elements ... float64) (float64, error)
}{
    Unary:          float64UnaryChecked{
        Abs:        float64UnaryCheckedAbs,
        Negation:   float64UnaryCheckedNegation,
    },
    
    Binary:         float64BinaryChecked{
        Add:        float64BinaryCheckedAdd,
        Sub:        float64BinaryCheckedSub,
        Mul:        float64BinaryCheckedMul,
        Div:        float64BinaryCheckedDiv,
    },
    
    Nary:           float64NaryChecked{
        Add:        float64NaryCheckedAdd,
        Mul:        float64NaryCheckedMul,
    },
    
    Reduce:         float64CheckedReduce,
}

func float64UnaryPositive(a float64) bool {
    return math.Signbit(float64(a)) == false
}

func float64UnaryNegative(a float64) bool {
    return math.Signbit(float64(a)) == true
}

func float64UnaryAbs(a float64) float64 {
    return float64(math.Abs(float64(a)))
}

// note abs(+/- Inf) = +Inf
func float64UnaryCheckedAbs(a float64) (v float64, err error) {
    if math.IsNaN(float64(a)) { return v, ErrorNaN }
    return float64(math.Abs(float64(a))), nil
}

func float64UnaryCheckedNegation(a float64) (v float64, err error) {
    if math.IsNaN(float64(a)) { return v, ErrorNaN }
    return -a, nil
}

func float64BinaryCheckedAdd(a float64, b float64) (v float64, err error) {
    if (b > 0) && (a > (maxFloat64 - b)) { return v, ErrorOverflow }
    if (b < 0) && (a < (minFloat64 - b)) { return v, ErrorOverflow }
    return a + b, nil
}

func float64BinaryCheckedSub(a float64, b float64) (v float64, err error) {
    if (b < 0) && (a > (maxFloat64 + b)) { return v, ErrorOverflow }
    if (b > 0) && (a < (minFloat64 + b)) { return v, ErrorOverflow }
    return a - b, nil
}

func float64BinaryCheckedMul(a float64, b float64) (v float64, err error) {
    if (a > (maxFloat64 / b)) { return v, ErrorOverflow }
    if (a < (minFloat64 / b)) { return v, ErrorOverflow }
    
    return a * b, nil
}

func float64BinaryCheckedDiv(a float64, b float64) (v float64, err error) {
    if math.IsNaN(float64(a)) { return v, ErrorNaN }
    if (b == 0) { return v, ErrorUndefined }
    
    return a / b, nil
}



func float64NaryAdd(xs ... float64) (result float64) {
    for i := 0; i < len(xs); i++ {
        result += xs[i]
    }
    return result
}

func float64NaryCheckedAdd(xs ... float64) (result float64, err error) {
    for i := 0; i < len(xs); i++ {
        result, err = float64BinaryCheckedAdd(result, xs[i])
        if err != nil { return result, err }
    }
    return result, nil
}

func float64NaryMul(xs ... float64) (result float64) {
    result = 1
    for i := 0; i < len(xs); i++ {
        result *= xs[i]
    }
    return result
}

func float64NaryCheckedMul(xs ... float64) (result float64, err error) {
    result = 1
    for i := 0; i < len(xs); i++ {
        result, err = float64BinaryCheckedMul(result, xs[i])
        if err != nil { return result, err }
    }
    return result, nil
}

func float64Reduce(operatorIdentity float64, operator func(float64, float64) float64, elements ... float64) (result float64) {
    result = operatorIdentity
    for i := 0; i < len(elements); i++ {
        result = operator(result, elements[i])
    }
    return result
}

func float64CheckedReduce(operatorIdentity float64, operator func(float64, float64) (float64, error), elements ... float64) (result float64, err error) {
    result = operatorIdentity
    for i := 0; i < len(elements); i++ {
        result, err = operator(result, elements[i])
        if err != nil { return result, err }
    }
    return result, err
}

