package operator

// Code generated by (tawesoft.co.uk/go/operator) template-numbers.py: DO NOT EDIT.


// Some overflow checks with reference to stackoverflow.com/a/1514309/5654201

type uint32Unary struct {
    Identity        func(uint32) uint32
    Not             func(uint32) uint32
    Zero            func(uint32) bool
    NonZero         func(uint32) bool
    Positive        func(uint32) bool
    Negative        func(uint32) bool
}

type uint32UnaryChecked struct {
}

type uint32Binary struct {
    Add             func(uint32, uint32) uint32
    Sub             func(uint32, uint32) uint32
    Mul             func(uint32, uint32) uint32
    Div             func(uint32, uint32) uint32
    Mod             func(uint32, uint32) uint32
    
    Eq              func(uint32, uint32) bool
    Neq             func(uint32, uint32) bool
    Lt              func(uint32, uint32) bool
    Lte             func(uint32, uint32) bool
    Gt              func(uint32, uint32) bool
    Gte             func(uint32, uint32) bool
    
    And             func(uint32, uint32) uint32
    Or              func(uint32, uint32) uint32
    Xor             func(uint32, uint32) uint32
    AndNot          func(uint32, uint32) uint32
    
    Shl             func(uint32, uint) uint32
    Shr             func(uint32, uint) uint32
}

type uint32BinaryChecked struct {
    Add             func(uint32, uint32) (uint32, error)
    Sub             func(uint32, uint32) (uint32, error)
    Mul             func(uint32, uint32) (uint32, error)
    
    Shl             func(uint32, uint) (uint32, error)
    Shr             func(uint32, uint) (uint32, error)
}

type uint32Nary struct {
    Add             func(... uint32) uint32
    Sub             func(... uint32) uint32
    Mul             func(... uint32) uint32
}

type uint32NaryChecked struct {
    Add             func(... uint32) (uint32, error)
    Sub             func(... uint32) (uint32, error)
    Mul             func(... uint32) (uint32, error)
}

// Uint32 implements operations on one (unary), two (binary), or many (nary) arguments of type uint32.
var Uint32 = struct {
    Unary           uint32Unary
    Binary          uint32Binary
    Nary            uint32Nary
    Reduce          func(operatorIdentity uint32, operator func(uint32, uint32) uint32, elements ... uint32) uint32
}{
    Unary:          uint32Unary{
        Identity:   func(a uint32) uint32 { return a },
        Not:        func(a uint32) uint32 { return ^a },
        Zero:       func(a uint32) bool { return a == 0 },
        NonZero:    func(a uint32) bool { return a != 0 },
        Positive:   uint32UnaryPositive,
        Negative:   uint32UnaryNegative,
    },
    
    Binary:          uint32Binary{
        Add:        func(a uint32, b uint32) uint32 { return a + b },
        Sub:        func(a uint32, b uint32) uint32 { return a - b },
        Mul:        func(a uint32, b uint32) uint32 { return a * b },
        Div:        func(a uint32, b uint32) uint32 { return a / b },
        
        Eq:         func(a uint32, b uint32) bool { return a == b },
        Neq:        func(a uint32, b uint32) bool { return a != b },
        Lt:         func(a uint32, b uint32) bool { return a <  b },
        Lte:        func(a uint32, b uint32) bool { return a <= b },
        Gt:         func(a uint32, b uint32) bool { return a >  b },
        Gte:        func(a uint32, b uint32) bool { return a >= b },
        
        And:        func(a uint32, b uint32) uint32 { return a & b },
        Or:         func(a uint32, b uint32) uint32 { return a | b },
        Xor:        func(a uint32, b uint32) uint32 { return a ^ b },
        AndNot:     func(a uint32, b uint32) uint32 { return a &^ b },
        Mod:        func(a uint32, b uint32) uint32 { return a % b },
        
        Shl:        func(a uint32, b uint) uint32 { return a << b },
        Shr:        func(a uint32, b uint) uint32 { return a >> b },
    },
    
    Nary:           uint32Nary{
        Add:        uint32NaryAdd,
        Mul:        uint32NaryMul,
    },
    
    Reduce:         uint32Reduce,
}

// Uint32Checked implements operations on one (unary), two (binary), or many (nary) arguments of type uint32, returning an
// error in cases such as overflow.
var Uint32Checked = struct {
    Unary           uint32UnaryChecked
    Binary          uint32BinaryChecked
    Nary            uint32NaryChecked
    Reduce          func(operatorIdentity uint32, operator func(uint32, uint32) (uint32, error), elements ... uint32) (uint32, error)
}{
    Unary:          uint32UnaryChecked{
    },
    
    Binary:         uint32BinaryChecked{
        Add:        uint32BinaryCheckedAdd,
        Sub:        uint32BinaryCheckedSub,
        Mul:        uint32BinaryCheckedMul,
        Shl:        uint32BinaryCheckedShl,
    },
    
    Nary:           uint32NaryChecked{
        Add:        uint32NaryCheckedAdd,
        Mul:        uint32NaryCheckedMul,
    },
    
    Reduce:         uint32CheckedReduce,
}

func uint32UnaryPositive(a uint32) bool {
    return a > 0
}

func uint32UnaryNegative(a uint32) bool {
    return a < 0
}




func uint32BinaryCheckedAdd(a uint32, b uint32) (v uint32, err error) {
    if (b > 0) && (a > (maxUint32 - b)) { return v, ErrorOverflow }
    if (b < 0) && (a < (minUint32 - b)) { return v, ErrorOverflow }
    return a + b, nil
}

func uint32BinaryCheckedSub(a uint32, b uint32) (v uint32, err error) {
    if (b < 0) && (a > (maxUint32 + b)) { return v, ErrorOverflow }
    if (b > 0) && (a < (minUint32 + b)) { return v, ErrorOverflow }
    return a - b, nil
}

func uint32BinaryCheckedMul(a uint32, b uint32) (v uint32, err error) {
    if (a > (maxUint32 / b)) { return v, ErrorOverflow }
    if (a < (minUint32 / b)) { return v, ErrorOverflow }
    
    return a * b, nil
}

func uint32BinaryCheckedShl(a uint32, b uint) (v uint32, err error) {
    if b > uint(uint32MostSignificantBit(maxUint32)) { return v, ErrorOverflow }
    return v, err
}

func uint32MostSignificantBit(a uint32) (result int) {
  for a > 0 {
      a >>= 1
      result++
  }
  return result;
}

func uint32NaryAdd(xs ... uint32) (result uint32) {
    for i := 0; i < len(xs); i++ {
        result += xs[i]
    }
    return result
}

func uint32NaryCheckedAdd(xs ... uint32) (result uint32, err error) {
    for i := 0; i < len(xs); i++ {
        result, err = uint32BinaryCheckedAdd(result, xs[i])
        if err != nil { return result, err }
    }
    return result, nil
}

func uint32NaryMul(xs ... uint32) (result uint32) {
    result = 1
    for i := 0; i < len(xs); i++ {
        result *= xs[i]
    }
    return result
}

func uint32NaryCheckedMul(xs ... uint32) (result uint32, err error) {
    result = 1
    for i := 0; i < len(xs); i++ {
        result, err = uint32BinaryCheckedMul(result, xs[i])
        if err != nil { return result, err }
    }
    return result, nil
}

func uint32Reduce(operatorIdentity uint32, operator func(uint32, uint32) uint32, elements ... uint32) (result uint32) {
    result = operatorIdentity
    for i := 0; i < len(elements); i++ {
        result = operator(result, elements[i])
    }
    return result
}

func uint32CheckedReduce(operatorIdentity uint32, operator func(uint32, uint32) (uint32, error), elements ... uint32) (result uint32, err error) {
    result = operatorIdentity
    for i := 0; i < len(elements); i++ {
        result, err = operator(result, elements[i])
        if err != nil { return result, err }
    }
    return result, err
}

